# TODO
# support Ilk & Urb object retrieval at a given block height
# polymorphic event types?
# type VowGov {}
# Queries
#
# Object History:
#
#   Urns: Use frob events?
#   Ilks: Snapshot each block?

# Vat.init.call
# -> create Ilk id: e.ilk
# Cat.file.call
# -> update Ilk id: e.ilk => ilks[e.ilk].chop ilks[e.ilk].lump ilks[e.ilk].flip
# Pit.file(ilk _).call
# -> update Ilk id: e.ilk => ilks[e.ilk].spot ilks[e.ilk].line
# Drip.file(ilk _).call
# -> update Ilk id: e.ilk => ilks[e.ilk].tax ilks[e.ilk].rho
# Vat.fold.call
# -> update Ilk id: e.ilk => ilks[e.ilk].rate
# Vat.tune.call
# -> update Ilk id: e.ilk => ilks[e.ilk].Ink ilks[e.ilk].Art
# Vat.grab.call
# -> update Ilk id: e.ilk => ilks[e.ilk].Ink ilks[e.ilk].Art
type Ilk {
  id:    String      # param: e.ilk                 desc: ilk identifier e.g ETH
  rate:  Float       # store: Vat.ilks[id].rate     desc: debt scaling factor
  spot:  Float       # store: Pit.ilks[id].spot     desc: price feed with margin
  line:  Float       # store: Pit.ilks[id].line     desc: debt ceiling
  chop:  Float       # store: Cat.ilks[id].chop     desc: liquidation penalty
  lump:  Float       # store: Cat.ilks[id].lump     desc: flip auction lot size
  flip:  Address     # store: Cat.ilks[id].flip     desc: flipper contract
  rho:   Era         # store: Drip.ilks[id].tax     desc: time of last drip
  tax:   Float       # store: Drip.ilks[id].rho     desc: tax
  Ink:   Float       # store: Vat.ilks[id].Ink      desc: total encumbered Gem
  Art:   Float       # store: Vat.ilks[id].Art      desc: total debt outstanding
  files: [FileEvent] # query: FileEvent(id: id)     desc: state change events
  bites: [BiteEvent] # query: BiteEvent(ilkId: id)  desc: ilk bite events
  frobs: [FrobEvent] # query: FrobEvent(ilkId: Id)  desc: ilk frob events
  created: Datetime
  updated: Datetime
}

# Vat.tune.call -> update Urn id: e.u ilkId: e.i
type Urn {
  id:      String       # param: e.urn                                desc: urn identifier
  ilkId:   String       # param: e.ilk                                desc: ilk identifier
  ilk:     Ilk          # query: Ilk(id: ilkId)                       desc: ilk object
  ink:     Float        # store: urns[iLk][urn].ink                   desc: locked gem
  art:     Float        # store: urns[ilk][urn].art                   desc: outstanding debt
  ratio:   Float        # query: (ink * ilk.spot) / (art * ilk.rate)  desc: collateralization ratio
  safe:    Boolean      # query: ratio > 1                            desc: true if sufficiently collateralized
  frobs:   [FrobEvent]  # query: FrobEvent(ilkId: ilkId urnId: id)    desc: state change events
  bites:   [BiteEvent]  # query: BiteEvent(ilkId: ilkId urnId: id)    desc: liquidation events
  created: Datetime
  updated: Datetime
}

# Cat.bite.call -> create Flip id: e.nflip
# Cat.flip.call -> update Flip id: e.n
type Flip {
  id:      Integer  # param: e.n || e.nflip   desc: flip identifier
  ink:     Float    # store: flips[n].ink     desc: remaining collateral to auction
  tab:     Float    # store: flips[n].tab     desc: remaining debt to recover
  created: Datetime
  updated: Datetime
}

# Vow.fess.call -> create Sin era: now
# Vow.flog.call -> update Sin era: e.era => flogged
type Sin {
  era:     Integer     # param: e.era               desc: bite timestamp
  tab:     Float       # store: sin[era]            desc: sin amount
  events:  SinEvent    # query: SinEvent(era: era)  desc: fess & flog events
  flogged: Boolean     #                            desc: true if flogged
  created: Datetime
  updated: Datetime
}

# Pit.file(what _).call -> update PitGov id: e.address
type PitGov {
  id:      String       # param: e.address          desc: contract address
  Line:    Float        # store: Pit.Line           desc: system debt ceiling
  files:   [FileEvent]  # query: FileEvent(id: id)  desc: state change events
  created: Datetime
  updated: Datetime
}

# Cat.file(what _).call -> update CatGov id: e.address
type CatGov {
  id:      String       # param: e.address          desc: contract address
  pit:     Address      # store: Cat.pit            desc: pit address
  vow:     Address      # store: Cat.vow            desc: vow address
  files:   [FileEvent]  # query: FileEvent(id: id)  desc: state change events
  created: Datetime
  updated: Datetime
}

# Drip.file(what _).call -> update DripGov id: e.address
type DripGov {
  id:      String       # param: e.address           desc: contract address
  repo:    Float        # store: Drip.repo           desc: debt scaling factor
  tax:     Float        # store: Drip.tax            desc: debt scaling factor
  files:   [FileEvent]  # query: FileEvent(id: id)   desc: state change events
  created: Datetime
  updated: Datetime
}

# Pit.frob.call -> create FrobEvent ilkId: e.ilk => e.dink e.dart
type FrobEvent {
  ilkId: String      # param: e.ilk              desc: ilk identifier
  ilk:   Ilk         # query: Ilk(               desc: ilk object at event block height
                     #   id:    ilkId,
                     #   block: tx.blockNumber
                     # )
  urnId: String      # param: e.urn              desc: urn identifier
  urn:   Urn         # query: Urn(               desc: urn object at event block height
                     #   id:    urnId,
                     #   ilkId: ilkId,
                     #   block: tx.blockNumber
                     # )
  dink:  Float       # param: e.dink             desc: ink delta
  dart:  Float       # param  e.dart             desc: art delta
  tx:    Tx          #                           desc: transaction meta
}

# Cat.bite.call -> create BiteEvent id: e.flip
type BiteEvent {
  id:    Integer     # param: e.flip             desc: flip identifier
  ilkId: String      # store: flips[id].ilk      desc: ilk identifier
  ilk:   Ilk         # query: Ilk(               desc: ilk object at event block height
                     #   id:    ilkId,
                     #   block: tx.blockNumber
                     # )
  urnId: String      # store: flips[id].urn      desc: urn identifier
  urn:   Urn         # query: Urn(               desc: urn object at event block height
                     #   id:    urnId,
                     #   ilkId: ilkId,
                     #   block: tx.blockNumber
                     # )
  ink:   Float       # store: ilks[id].ink       desc: siezed collateral
  tab:   Float       # store: ilks[id].tab       desc: debt to recover including liq. penalty
  art:   Float       # param: e.art              desc: siezed debt
  bids:  [Bid]       # query: Bid(biteId: id)    desc: collateral auction(s)
  flip:  Flip        # query: Flip(id: id)       desc: flip state
  flips: [FlipEvent] # query: FlipEvent(id: id)  desc: flip events
  tx:    Tx          #                           desc: transaction meta
}

# Cat.flip.call
# -> create FlipEvent id: e.n
# -> create Bid id: e.id
type FlipEvent {
  id:      Integer   # param: e.n     desc: flip identifier
  wad:     Float     # param: e.wad   desc: flip amount
  tx:      Tx        #                desc: transaction meta
}

# Pit.file(ilk _).call   -> create FileEvent id: e.ilk
# Pit.file(what _).call  -> create FileEvent id: e.address
# Cat.file(ilk _).call   -> create FileEvent id: e.ilk
# Cat.file(what _).call  -> create FileEvent id: e.address
# Drip.file(ilk _).call  -> create FileEvent id: e.ilk
# Drip.file(what _).call -> create FileEvent id: e.address
type FileEvent {
  id:    String   # param: e.address          desc: contract address
  ilkId: String   # param: e.ilk              desc: ilk identifier
  ilk:   Ilk      # query: Ilk(               desc: ilk object at event block height
                  #   id:    ilkId,
                  #   block: tx.blockNumber
                  # )
  what:  String   # param: e.what             desc: field to update
  data:  String   # param: e.data             desc: parsed data - number or address
  tx:    Tx       #                           desc: transaction meta
}

# Vow.fess.call -> create SinEvent era: now
# Vow.flog.call -> create SinEvent era: e.era
type SinEvent {
  era:    Integer  # param: e.era desc: flogs storage key
  tx:     Tx       #              desc: transaction meta
}

type Query {

   # Collection Arguments
   # first: Only read the first `n` values # of the set.
   # last: Only read the last `n` values # of the set.
   # offset: Skip the first `n` values from our `after`
   # cursor, an alternative to cursor based pagination. May
   # not be used with `last`.
   # before: Read all values in the set
   # before (above) this cursor.
   # after: Read all values in the set
   # after (below) this cursor.
   # orderBy: The method to use when ordering `OasisTrade`.
   # condition: A condition to be used in determining which values should be
   # returned by the collection.
   # filter: A filter to be used in determining which values should be returned
   # by the collection.

   allIlks(
     first:     Int,
     last:      Int,
     offset:    Int,
     before:    Cursor,
     after:     Cursor,
     orderBy:   IlkOrderBy,
     condition: IlkCondition,
     filter:    IlkFilter
   ): [Ilk]

   allIlkStates(
     # Collection arguments
     # ...
     interval: String # optionally specify a postgres aggregation interval e.g '1 day'
   ): [Ilk]

   getIlk(
     id: String!
     blockNumber: Int # optionally retrieve ilk state at a given block height
   ): Ilk

   allUrns(
     first:     Int,
     last:      Int,
     offset:    Int,
     before:    Cursor,
     after:     Cursor,
     orderBy:   UrnOrderBy,
     condition: UrnCondition,
     filter:    UrnFilter
   ): [Urn]

   getUrn(
     ilkId: String!
     urnId: String!
     blockNumber: Int # optionally retrieve ilk state at a given block height
   ): Urn

   allUrnStates(
     # Collection arguments
     # ...
     interval: String # optionally specify a postgres aggregation interval e.g '1 day'
   ): [Urn]

   allFiles(
     first:     Int,
     last:      Int,
     offset:    Int,
     before:    Cursor,
     after:     Cursor,
     orderBy:   FileOrderBy,
     condition: FileCondition,
     filter:    FileFilter
   ): [FileEvent]

   allFrobs(
     first:     Int,
     last:      Int,
     offset:    Int,
     before:    Cursor,
     after:     Cursor,
     orderBy:   FrobOrderBy,
     condition: FrobCondition,
     filter:    FrobFilter
   ): [FrobEvent]

   allBites(
     first:     Int,
     last:      Int,
     offset:    Int,
     before:    Cursor,
     after:     Cursor,
     orderBy:   BiteOrderBy,
     condition: BiteCondition,
     filter:    BiteFilter
   ): [BiteEvent]
}
